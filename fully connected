module fc (
  input wire signed [8:0] in0, in1, in2, in3,
  input wire signed [8:0] w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15, w16, w17, w18, w19, w20, w21, w22, w23, w24, w25, w26, w27, w28, w29, w30, w31, w32, w33, w34, w35, w36, w37, w38, w39, b0,
  input wire [7:0] iexp, wexp, bexp,
  output wire signed [8:0] out0, out1, out2, out3,
  output wire [7:0] oexp
);
  wire [7:0] tmpexp;
  exponent_multiply exp (.a(iexp), .b(wexp), .exponent(tmpexp));
  wire signed [16:0] shifted_bias = {b0[8], 1'b0, b0[7:0], 7'b0000000} >> tmpexp - bexp;
  wire [20:0] tmpo0, tmpo1, tmpo2, tmpo3;
  wire [2:0] overflow0, overflow1, overflow2, overflow3, expshift;
  fully first0 (.i0(in0), .w0(w0), .w1(w1), .w2(w2), .w3(w3), .w4(w4), .w5(w5), .w6(w6), .w7(w7), .w8(w8), .w9(w9), .b0(shifted_bias), .out(tmpo0), .overflow(overflow0));
  fully first1 (.i0(in1), .w0(w10), .w1(w11), .w2(w12), .w3(w13), .w4(w14), .w5(w15), .w6(w16), .w7(w17), .w8(w18), .w9(w19), .b0(shifted_bias), .out(tmpo1), .overflow(overflow1));
  fully first2 (.i0(in2), .w0(w20), .w1(w21), .w2(w22), .w3(w23), .w4(w24), .w5(w25), .w6(w26), .w7(w27), .w8(w28), .w9(w29), .b0(shifted_bias), .out(tmpo2), .overflow(overflow2));
  fully first3 (.i0(in3), .w0(w30), .w1(w31), .w2(w32), .w3(w33), .w4(w34), .w5(w35), .w6(w36), .w7(w37), .w8(w38), .w9(w39), .b0(shifted_bias), .out(tmpo3), .overflow(overflow3));
  
  maxoverflow get_shift (.a(overflow0), .b(overflow1), .c(overflow2), .d(overflow3), .max(expshift));

  assign oexp = tmpexp + expshift;
  assign out0 = tmpo0[20:12] + tmpo0[11];
  assign out1 = tmpo1[20:12] + tmpo1[11];
  assign out2 = tmpo2[20:12] + tmpo2[11];
  assign out3 = tmpo3[20:12] + tmpo3[11];
  //assign out0 = tmpo0[20:12];
  //assign out1 = tmpo1[20:12];
  //assign out2 = tmpo2[20:12];
  //assign out3 = tmpo3[20:12];
  
endmodule

module sign_multiply(
  input wire a, b,
  output wire sign
);
  assign sign = a^b;
endmodule

module exponent_multiply(
  input wire [7:0] a, b,
  output wire [7:0] exponent
);
  assign exponent = a+b-8'd127;
endmodule

module mantissa_multiply (
  input [7:0] a, b,
  output wire [15:0] mantissa
);
  assign mantissa = a*b;
endmodule

module bfp_multiply (
  input wire [8:0] a, b,
  output wire [16:0] product
);
  wire sign;
  wire [15:0] mantissa;
  sign_multiply get_sign (.a(a[8]), .b(b[8]), .sign(sign));
  mantissa_multiply get_mantissa (.a(a[7:0]), .b(b[7:0]), .mantissa(mantissa));
  assign product = {sign, mantissa};
endmodule


module fcaddition (
  input wire signed [16:0] a, b, c, d, e, f, g, h, i, j,
  input wire signed [16:0] bias,
  output wire signed [20:0] sum,
  output reg [2:0] overflow
);
  assign sum = $signed(a) + $signed(b) + $signed(c) + $signed(d) + $signed(e) + $signed(f) + $signed(g) + $signed(h) + $signed(i) + $signed(j) + $signed(bias);
  always @(*) begin
      if (sum[19]) overflow = 3'b101;
      else if (sum[18]) overflow = 3'b100;
      else if (sum[17]) overflow = 3'b011;
      else if (sum[16]) overflow = 3'b010;
      else if (sum[15]) overflow = 3'b001;
      else overflow = 3'b000;
  end
endmodule

module fully (
  input wire [8:0] i0,
  input wire [8:0] w0, w1, w2, w3, w4, w5, w6, w7, w8, w9,
  input wire [16:0] b0,
  output wire [20:0] out,
  output wire [2:0] overflow
);
  wire signed [16:0] a, b, c, d, e, f, g, h, i, j;
  bfp_multiply a0 (.a(i0), .b(w0), .product(a));
  bfp_multiply a1 (.a(i0), .b(w1), .product(b));
  bfp_multiply a2 (.a(i0), .b(w2), .product(c));
  bfp_multiply a3 (.a(i0), .b(w3), .product(d));
  bfp_multiply a4 (.a(i0), .b(w4), .product(e));
  bfp_multiply a5 (.a(i0), .b(w5), .product(f));
  bfp_multiply a6 (.a(i0), .b(w6), .product(g));
  bfp_multiply a7 (.a(i0), .b(w7), .product(h));
  bfp_multiply a8 (.a(i0), .b(w8), .product(i));
  bfp_multiply a9 (.a(i0), .b(w9), .product(j));
  fcaddition get (.a(a), .b(b), .c(c), .d(d), .e(e), .f(f), .g(g), .h(h), .i(i), .j(j), .bias(b0), .sum(out), .overflow(overflow));
endmodule

module maxoverflow (
  input wire [2:0] a, b, c, d,
  output wire [2:0] max
);
  wire [2:0] tmp0, tmp1;
  assign tmp0 = (a >= b) ? a : b;
  assign tmp1 = (c >= d) ? c : d;
  assign max = (tmp0 >= tmp1) ? tmp0 : tmp1;
endmodule
